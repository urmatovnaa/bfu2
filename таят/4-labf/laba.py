def cyk_parse(string, grammar):
    # Длина входной строки
    n = len(string)
    
    # Создаем таблицу CYK (n x n)
    table = [[set() for _ in range(n)] for _ in range(n)]

    # Заполнение таблицы для единичных символов
    for i in range(n):
        for lhs, productions in grammar.items():
            if string[i] in productions:
                table[i][i].add(lhs)

    # Заполнение таблицы для подстрок длиной от 2 до n
    for length in range(2, n + 1):  # длина подстроки
        for start in range(n - length + 1):  # начало подстроки
            end = start + length - 1  # конец подстроки
            for split in range(start, end):  # разделяем подстроку
                for lhs, productions in grammar.items():
                    for production in productions:
                        if len(production) == 2:  # Проверка только на два нетерминала
                            if production[0] in table[start][split] and production[1] in table[split + 1][end]:
                                table[start][end].add(lhs)

    # Проверка, может ли начальный символ S' порождать всю строку
    return 'S\'' in table[0][n - 1]

# Пример грамматики в формате словаря
grammar = {
    'S\'': ['+A'],
    'A': ['aD'],
    'D': ['BC'],
    'B': ['bB', 'bc'],  # Правила для B
    'C': ['c']          # Правила для C
}

# Входная строка
input_string = '+abbbbbbccccc'

# Проверка разбора
if cyk_parse(input_string, grammar):
    print(f"The string '{input_string}' can be generated by the grammar.")
else:
    print(f"The string '{input_string}' cannot be generated by the grammar.")

