"""“Термин” широковещание ” описывает, как numpy обрабатывает массивы с различными формами во время арифметических операций.
При соблюдении определенных ограничений меньший массив “транслируется” по большему массиву, чтобы они имели совместимые формы.
Широковещательная передача предоставляет средство векторизации операций с массивами, чтобы циклическое выполнение происходило в C вместо Python.

Правила вещания Numpy
Numpy broadcasting имеет строгий набор правил, чтобы сделать работу с массивами последовательной и безотказной. Это два общих правила вещания в numpy:
Когда мы выполняем операцию над массивами NumPy , NumPy сравнивает форму массива по элементам справа налево.
Два измерения совместимы только тогда, когда они равны или одно из них равно 1. Если два измерения равны, массив остается нетронутым.
Если измерение одно, массив транслируется по этому измерению. Если ни одно из двух условий не выполняется, NumPy выдает ошибку ValueError,
указывающую, что массив не может быть передан. Массивы транслируются тогда и только тогда, когда все измерения совместимы.
Сравниваемые массивы не обязательно должны иметь одинаковое количество измерений. Массив, имеющий меньшее количество измерений,
можно легко масштабировать по отсутствующему измерению.”"""

#numpy широковещание (broadcasting)
import numpy as np
#
a = np.arange(12).reshape(4, 3)
print("Shape of a is:", a.shape)

b = np.arange(4).reshape(4, 1)
print("Shape of b is:", b.shape)
print(a)
print(b)
print("Sum: \n", a + b)

"""Сумма массивов, имеющих совместимые размеры: Массивы имеют размеры (4, 3) и (4, 1), которые совместимы. 
Массив b растягивается вдоль 2-го измерения, чтобы соответствовать измерению a."""

a = np.arange(32).reshape(4, 4, 1, 2)
print("Shape of a is:", a.shape)
# print(a)

b = np.arange(8).reshape(1,4,2)
print("Shape of b is:", b.shape)
# print(b)

print("Shape of the sum: \n", (a + b).shape)
# print(a + b)

"""Важно отметить, что несколько массивов могут транслироваться по нескольким измерениям. Массив a имеет размеры (4, 4, 1, 2), 
а массив b имеет размеры (1, 4, 2). Массив a растягивается вдоль третьего измерения, в то время как массив b растягивается вдоль 1-го и 2-го измерения,
давая результирующий массив измерения (4, 4, 4, 2).
Вещание Numpy происходит быстрее, чем зацикливание по массиву. Возьмем первый пример. 
Пользователь может решить не использовать механизм широковещания и выполнить цикл по всему массиву, 
чтобы добавить одно и то же число к каждому элементу в массиве. Это может быть медленным в основном по двум причинам – зацикливание включает в себя
взаимодействие с циклом python , что отнимает часть скорости реализации C. Во-вторых, NumPy использует шаги вместо цикла. 
Установка шагов размера 0 позволяет бесконечно повторять элементы без каких-либо затрат памяти."""